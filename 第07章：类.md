# Chapter_07 Tips

## const成员函数
```C
std::string isbn() const {return bookNo;}
```
>这里，const的作用是修改隐式this指针的类型  
>默认情况下，this的类型是 **指向类类型非常量版本的常量指针** (Sales_data *const)  
>紧跟在参数列表后面的const表示this是一个 **指向常量的指针** (const Sales *cosnt)。  
>像这样使用const的成员函数被称作 **常量成员函数(const memeber function)**

## 可变数据成员
>可以通过在变量的声明中加入mutable关键字做到这一点  
>一个 **可变数据成员(mutable data member)** 永远不会是const，即使它是const对象的成员

## 委托构造函数
>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的 **委托构造函数(delegating constructor)**。  
>一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责托给了其他构造函数。

## 抑制构造函数定义的隐式转换(explicit)
>在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为 *explicit* 加以阻止  
>explicit构造函数只能用于直接初始化

## 聚合类
>聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。以下为聚合类条件：  
- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有virtual函数

## 类的静态成员
>类的静态成员存在于任何对象之外，对象中不包括任何与静态数据成员有关的数据。  
>静态成员函数也不与任何对象绑定在一起，他们不包括this指针。

## Notes
>定义在类内部的函数是隐式的inline函数  
>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。  
