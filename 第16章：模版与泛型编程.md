# 第十六章 模板与泛型编程
- 模板是C++泛型编程的基础。
- 一个模板局势创建一个类或函数的蓝图或者说公式。

## 定义模板
>如果希望比较的类型都不得不重复定义完全一样的函数体，是非常繁琐且容易出错的。
### 函数模板
- 我们可以定义一个通用的函数模板(function template)，而不是为每个类型都定义一个新函数。
- 一个函数就是一个公式，可用来生成针对特定类型的函数版本
>compare的模板版本可能相下面这样：
```C++
template <typename T>
int compare(cosnt T &v1, cosnt T &v2)
{
    if(v1 < v2>)
    {
        return -1;
    }
    if(v2 < v1>)
    {
        return 1;
    }
    return 0;
}
```
- 模板以关键字tempalate开始，后跟一个模板参数列表(tempalte parameter list)，这是一个逗号分隔的一个或多个模板参数(tempalte paramater)。  
- 在模板定义中，模板参数列表不能为空。  
#### 实例化函数模板
- 当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参。  
- 编译器用推断出的模板参数来为我们实例化(instantiate)一个特定类型的函数。
#### 模板类型参数
- 我们的模板参数有一个模板类型参数(type parameter)。  
- 一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明一样使用。  
- 特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。
#### 非类型模板参数
- 除了定义类型参数，还可以在模板中定义非类型参数(notype parameter)。  
- 一个非类型参数表示一个值而非一个类型。  
- 我们通过一个特定的类型名而非关键字class或typename来指定类型参数。  
- 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值代替。**这些值必须是常量表达式**，从而允许编译器在编译时实例化模板。  
```C++
template<unsigned N, unisgned M>
int compare(cosnt char (&p1)[N], cosnt char (&p2)[M])
{
    return strcmp(p1, p2);
}
```
>当我们调用这个版本compare时：
```C++
compare("hi", "mon");
```
- 编译器会使用字面常量的大小来代替N和M，从而实例化模板。
- 记住，编译器会在一个字符串字面常量的末尾插入空字符串作为终结符，因此编译器会实例化出如下版本：
```C++
int compare(cosnt char(&p1)[3], cosnt char(&p2)[4]);
```
#### inline和constexpr函数模板
- 函数可以声明为inline和constexpr的，如同模板函数一样。
- inline或constexpr说明符放在模板参数列表之后，返回类型之前。
```C++
template<typename T>
inline T min(cosnt &T, cosnt &T);
```
#### 编写类型无关的代码
>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：
- 模板中的函数参数是const的引用。
- 函数体中的条件判断仅使用<比较运算。
#### 模板编译
- 当我们实例化模板的一个特定版本时，编译器才会生成代码。
- 当我们使用(而不是定义)模板时，编译器才生成代码
- **函数模板和类模板成员函数的定义通常放在头文件中。**
#### 大多数编译错误在实例化期间报告
>模板直到实例化时才会生成代码 ，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。
- 第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就那么多了。
- 第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确，它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。
- 第三个阶段是模板实例化时。只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

### 类模板
- 类模板是用来生成类的蓝图。
- 与函数模板不同的是，编译器不能为类模板推断模板参数。
#### 定义类模板
- 类似函数模板，类模板以关键字template开始，后跟模板参数列表。
- 在类模板(及其成员)的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。
```C++
template<typename T>
class Classtemplate
{
public:
    Classtemplate();
};
```
#### 实例化类模板
- 当使用一个模板时，我们必须提供额外信息。
- 这些额外信息是 **显示模板实参(explicit template argument)列表**，它们被绑定到模板参数。
- 编译器使用这些模板实参来实例化出特定的类。
#### 在模板作用域中引用模板类型
- 类模板用来实例化类型，而一个实例化的类型包含模板参数的。
- 我们通常将模板自己的参数当作被使用模板的实参。
#### 类模板的成员函数
- 我们既可以在类模板内部，也可以在类模板外部定义成员函数。
- 且定义在类模板内部的成员函数被隐式声明为内联函数。
- 类模板的每个实例都有其自己版本的成员函数。
- 类模板的成员函数具有和模板相同的模板实参。
- 定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。
```C++
template<typename T>
int Classtemplate<T>::mem()
{
    return 0;
}
```
#### 类模板成员函数的实例化
- 默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。
- 这一特性使得某种类型使得即使某种类型不能完全符合模板的操作的要求，我们仍然能用该类型实例化类。
#### 在类代码内简化模板的类名的作用
- 当我们使用一个模板类型时必须提供模板实参，但这一规则有一个例外。
- 在类模板自己的作用域中我们可以直接使用模板名而不提供实参。
#### 在类模板外使用类模板名
- 当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。
- 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。
#### 类模板和友元
- 当一个类包含一个友元声明时，类与友元各自是否是模板相互无关的。
- 一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。
- 如果友元自身是模板，类可以授权所有友元模板实例，也可以只授权给特定实例。
#### 一对一友好关系
- 类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。
#### 通用和特定的模板友好关系
- 一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元。
#### 令模板自己的类型参数成为友元
- 在新标准中我们可以将模板类型参数声明称为友元。
#### 模板类型别名
- 类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 *typedef* 来引用实例化的类。
#### 类模板的static成员
- 与其他类相同，类模板可以声明static成员。
- 类模板的每个实例都有一个独有的static对象。

### 模板参数
#### 模板参数与作用域
- 模板参数遵循普通的作用域规则。
- 一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。
- 与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。
- 但是，在模板中不能重用模板参数名。
#### 模板声明
- 模板声明必须包含模板参数。
- 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。
- 出现于任何使用这些模板的代码之前。
#### 使用类的类型成员
- 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。
- 我们通过使用关键字 *typename* 来显示的告诉编译器该名字是一个类型。
#### 默认模板实参
- 我们也可以为模板提供 **默认实参(default template argument)**。
- 在新标准中，我们可以为函数和类模板提供默认实参。
- 而更早的C++标准只允许为类模板提供默认实参。
#### 模板默认实参与类模板
- 不论何时使用一个类模板，我们都必须在模板之后接上尖括号。
- 尖括号指出类必须从一个模板实例化而来。
- 特别是我们希望使用默认实参时，就必须在模板名之后跟一个空尖括号对。

### 成员模板
- 一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。
- 这种成员被称为 **成员模板(member template)**。
- 成员模板不能是虚函数。
#### 类模板的成员模板
- 对于类模板，我们可以为其定义成员模板。
- 在此情况下，类和成员各有自己的，独立的模板参数。
#### 实例化与成员模板
- 为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。
- 编译器通常会根据传递给成员模板的函数实参来推断它的模板实参。

### 控制实例化
- 当模板在使用时才会实例化这一特性意味着，相同的实例可能出现在多个对象文件中。
- 在新标准中，我们可以通过 **显示实例化(explict instantiation)** 来避免这种开销。
>一个显示实例化有如下形式:
```C++
extern template declaration;    //实例化声明
template declaration;           //实例化定义
```
>declaration是一个类或函数的声明，其中所有模板参数已被替换为模板实参。
#### 实例化定义会实例化所有成员
- 一个类模板的实例化会实例化该模板的所有成员，包括内联的成员函数。
- 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。


## 模板参数推断
- 从函数实参来确定模板参数的过程被称为 **模板实参推断(template argument deductio)**。

### 类型转换与模板类型参数
- 与非模板参数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形参。
- 如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。
- 只有很有限的几种类型转换会自动应用于于这些实参。
- 编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。
#### 使用相同模板参数类型的函数形参
- 一个模板类型参数可以用作多个函数形参的类型。
- 由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。
#### 正常类型转换应用于普通函数实参
- 函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。
- 这种函数实参不进行特殊处理。它们正常转换为对应形参的类型。

### 函数模板显式实参
- 在某些情况下，编译器无法推断出模板实参的类型。
- 在其他一些情况下，我们希望允许用户控制模板实例化
- 当函数返回类型于参数列表中任何类型都不相同时，这两种情况最常出现。
#### 指定显示模板实参
- 我们提供 **显示模板实参(explict template argument)** 的方式与定义类模板实例的方式相同。
- 显示模板实参在尖括号中给出，位于函数名之后，实参列表之前:
```C++
auto val = sum<long long>(i, lng);//long long sum (int, long)
```
#### 正常类型转换应用于显示指定的实参
- 对于普通类型定义的函数参数，允许进行正常的类型转换。
- 出于同样的原因，对于模板类型参数已经显示指定了的函数实参，也进行正常的类型转换。

### 尾置返回类型与类型转换
- 当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效的。
- 但在其他情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么好处。
#### 进行类型转换的标准库模板类
- 为了获得元素类型，我们可以使用标准库的 **类型转换(type transformation)** 模板。
- 这些模板定义在头文件 *type_traits* 中。
- 这个头文件的类通常用于所谓的模板元编程程序设计。

### 函数指针和实参推断
- 当我们用一个函数模板初始化一个函数指针或为一个函数执政赋值时，编译器使用指针的类型来推断模板参数。
- 当参数是一个函数模板实例时，程序上下文必须满足：对每个模板参数，能唯一确定器类型或值。

### 模板实参推断和引用
- 编译器会应用正常的引用绑定规则。
- const是底层的，不是顶层的。
#### 从左值引用函数参数推断类型
- 第一种情况
    - 当一个函数参数是模板类型参数的一个普通(左值)引用时，绑定规则告诉我们。
    - 只能传递给它一个左值(如，一个变量或一个返回引用类型的表达式)。
    - 实参可以是const类型，也可以不是。
    - 如果实参是const的，则T被推断为const类型。
- 第二种情况
    - 如果函数参数的类型是cosnt T&，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象(const或非const)、一个临时对象或是一个字面值常量。
    - 当函数参数本身是const时，T的类型推断结果不会是一个const类型。
    - const已经是函数参数类型的一部分；因此，它不会也是模板参数的一部分。
#### 从右值引用函数推断类型
- 当一个函数参数是一个右值引用时，正常绑定规则告诉我们可以传递给它一个右值。
- 当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。
- 推断出的T的类型是该右值实参的类型。
#### 引用折叠和右值引用参数
- C++语言在正常绑定规则之外定义了两个例外规则，允许这样的绑定。这两个例外规则是move这种标准库设施正确工作的基础。
- 第一个例外规则影响右值引用参数的推断如何进行:
    - 当我们将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时。
    - 编译器推断模板类型参数为实参的左值引用类型。
- 第二种例外情况：
    - 如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。
    - 在所有情况下(除了一个例外)，引用会折叠成一个普通的左值引用类型。
    - 在新标准中，折叠规则扩展到右值引用。
    - 只在一种特殊情况下引用下引用会折叠成右值引用：右值的右值引用。
#### 编写右值引用参数的模板函数
- 模板参数可以推断为一个引用类型。

### 转发
- 某些函数需要将其一个或多个实参连同类型不变的转啊给其他函数。
- 再次情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参时左值还是右值。
#### 定义能保持类型信息的函数参数
- 通过将一个函数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。


## 重载与模板
- 函数模板可以被另一个模板或普通非模板重载。
- 与往常一样，名字相同的函数必须具有不同数量或类型的参数。
### 多个可行模板
- 当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。
### 非模板和模板重载
- 对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。
### 缺少声明可能导致程序行为异常
- 在定义任何函数之前，记得声明所有重载的函数版本。
- 这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。

## 可变参数模板
- 一个 **可变参数模板(variable template)** 就是一个接受可变数目参数的模板函数或模板类。
- 可变数目的参数被称为 **参数包(parameter packet)**。
- 存在两种参数包：
    - **模板参数包(template parameter packet)**，表示零或多个模板参数。
    - **函数参数包(function parameter packet)**，表示零或多个函数参数。
#### sizeof...运算符
- 但我们需要知道包中有多少元素时，可以使用sizeof...运算符。
### 编写可变参数函数模板
- 可变参数函数通常是递归的。
- 第一步调用处理包的第一个实参，然后用剩余实参调用自身。
- 每次递归调用将第二个实参打印到第一个实参表示的流中。
- 为了终止递归我们还需要定义一个非可变参数的print函数。
### 包扩展
- 对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展(expand)它。
- 当扩展一个包时，我们还要提供用于每个扩展元素的模式(pattern)。
- 扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。
- 我们通过在模式右边放一个省略号(...)来触发扩展操作。
### 转发参数包
在新标准下，我们可以组合使用可变参数模板与forward机制来编写函数，实现将其实参不变地传递给其他函数。


## 模板特例化
- 在一些时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从通用模板实例化。
- 当我们不能(或不希望)使用模板本版本时，可以定义类或函数模板的一个特例化版本。
### 定义函数模板特例化
- 当我们特例化一个函数模板时，必须为原模版中的每个模板参数都提供实参。
- 为了指出我们正在实例化一个模板，应使用关键字template后跟一个尖括号对。
- 尖括号对指出我们将为原模版所有模板参数提供实参。
### 函数重载与模板特例化
- 当定义函数模板地特例化版本时，我们本质上接管了编译器地工作。
- 即，我们为原模版地一个特殊实例提供了定义。
- 重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。
#### Tips
- 模板及其特例化版本应该特声明在同一个头文件中。
- 所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。
### 类模板特例化
- 除了可以特例化函数模板，我们还可以特例化类模板。
### 类模板部分特例化
- 与函数模板不同，类模板特例化不必为所有模板函数提供实参。
- 我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。
- 一个类模板的 **部分特例化(partial specialization)** 本身是一个模板，使用它时用户还必须为哪些在特例化版本中未指定的模板参数提供实参。
### 特例化成员而不是类
- 我们可以只特例化特定成员而不是整个模板。