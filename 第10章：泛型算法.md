# 第十章 泛型算法

## 概述
>顺序容器只定义了很少的操作。  
>标准库并未每个容器都定义成员函数来实现这些操作，而是定义了一组 **泛型算法(generic algorithm)**  
>称它们为“算法”，是因为她们实现了一些经典算法的公共接口。  
>称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型  
>大多数算法都定义在 *algorithm* 中，标准库还在头文件 *numeric* 中定义了一组数值泛型算法  
>一般情况下这些算法并不直接操作容器，而是遍历有两个迭代器指定的一个元素范围  

## 算法如何工作
>迭代器令算法不依赖容器  
>但算法依赖于元素类型的操作

## 只读算法
- find()
    >在指定范围内寻找指定的值
- count()
    >寻找在指定范围内要寻找的值出现了多少次
- accumulate()
    >对指定范围的元素求和
- equal()
    >用于确定两个序列是否保存相同的值

## 写容器元素的算法
- fill()
    >将指定的值赋值给一个指定的范围
- fill_n()
    >从指定起点起对一个范围赋值指定的值

## 拷贝算法
- copy()
    >将指定范围内元素拷贝到另一个容器的尾部

## 重排容器元素的算法
- sort()
    >对指定范围内的元素使用元素类型的 < 运算符来实现排序
- unique()
    >对指定范围内的元素消除相邻的重复项(容器大小不变)

## 向算法传递函数
### 谓词(predicate)
>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。  
>标准库算法所使用的谓词分为两类：
- 一元谓词(unary predicate)
    >意味着它们只接受单一参数
- 二元谓词(binary predicate)
    >意味着它们有两个参数
>接受谓词参数的算法对输入序列中的元素调用谓词。  
>因此，元素类型必须能转转成谓词的参数类型。

## lambda表达式(lambda expression)
>我们可以向一个算法传递任何类别的 **可调用对象(callable object)** 。  
>对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。  
>一个lambda表达式表示一个可调用的代码单元。  
>我们可以将其理解为一个未命名的内联函数  

### lambda表现形式：
```
[capture-list](parameter-list) -> return-type {function-body}
```
>其中captulist(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)  
>return-type，parameter-list，function-body与普通函数一样分别表示返回类型、参数列表、函数体  
>但是，与普通函数不同lambda必须使用尾置返回来指定返回类型  
>我们可以忽略参数列表和返回类型，但必须永远包含捕获泪飙和函数体

### 向lambda传递参数
>与一个普通函数调用类似，调用一个lambda时给定的参数被用来初始化lambda的形参。
>通常实参与形参的类型必须匹配，但与普通函数不同，lambda不能有默认参数。因此一个lambda调用的实参数目永远与形参数目相等。
>一旦形参初始化完毕，就可以执行函数体了

### lambda捕获和返回
>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。  
>可以这样理解，当一个函数传递lambda时，同时定义了一个新类型和该类型的对象：传递的参数就是此编译器生成的类类型的未命名对象。
>

### 使用捕获列表
>虽然一个lambda可以出现在一个函数中使用其局部变量，但它只能使用那些明确指明的变量。  
>默认情况下，从lambda生成的类都包含一个对应的该lambda所捕获的变量的数据成员  
>类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化  
#### 变量捕获方式
>类似于参数传递
- 值捕获
- 引用捕获
- 隐式捕获
    >除了显示列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。  
    >为了指示编译器来推断捕获列表，应在捕获列表中写一个 **&或=**
    >**&** 告诉编译器采用捕获引用方式
    >**=** 告诉编译器采用值捕获方式

### 可变lambda
>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。  
>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 *mutable*

## 参数绑定
### 标准库bind函数
>我们可以解决向函数传递一个长度参数的问题。  
>方法是使用一个新的名为 **bind** 的标准库函数，它定义在头文件 **functional** 中  
>可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适配”原对象的参数列表  
>调用bind的一般形式为：
```
auto newCallable = bind(callable, arg_list);
```
### 使用 *placeholders* 名字
>名字 **_n** 都定义在名为 **placeholders** 的命名空间中，而这个命名空间本身定义在 **std** 命名空间中。
### 绑定引用参数
>如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库 **ref** 或 **cref**函数

## 再探迭代器
>除了为每个容器迭代器之外，标准库还在头文件iterator中定义了额外几种迭代器：
- 插入迭代器(insert iterator)
    >这些迭代器被绑定在一个容器上，可用来向容器插入元素。
- 流迭代器(stream iterator)
    >这些迭代器被绑定在输入或输出流上，可用来遍历所关联的IO流。
- 反向迭代器(reverse iterator)
    >这些迭代器向后而不是向前移动。除了forward——list之外的标准库都有反向迭代器
- 移动迭代器(move iterator)
    >这些专用的迭代器向后而不是拷贝其中的元素，而是移动它们。

### 插入迭代器
>插入器是一种迭代器适配器，他接受一个容器，生成一个迭代器，能实现向给定的容器添加元素
>当我们通过一个插入器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。
>插入迭代器有三种类型差异在于元素插入的位置：
- back_inserter
- front_inserter
- inserter

### 流迭代器
>虽然iostream类型不是容器但标准库还是定义了可以用于IO类型对象的迭代器
- iseream_iterator
    >读取输入流
- ostream_iterator
    >向一个输出流写数据

### 反向迭代器
>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。  
>对于反向迭代器递增(以及递减)的含义会颠倒过来。
- 递增一个反向迭代器会移动到前一个元素。
- 递减一个反向迭代器会移动到后一个元素。

## 泛型算法结构
>任何算法的最基本的特征是它要求其迭代器提供哪些操作。  
>算法所要求的迭代器操作可以分为5个迭代器类别(iterator category)：
- 输入迭代器
    >只读，不写；单遍扫描，只能递增。
- 输出迭代器
    >只写，不读；单遍扫描，只能递增。
- 前向迭代器
    >可读写；多遍扫描，只能递增。
- 双向迭代器
    >可读写；多遍扫描，可递增递减。
- 随机访问迭代器
    >可读写；多遍扫描，支持全部迭代器操作。


## Notes
### 插入迭代器(insert iterator)
- 插入迭代器是一种向容器元素中添加元素的迭代器。  
- 通常情况下当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。  
- 当我们通过一个插入迭代器赋值时，一个与赋值符号右侧相等的元素被添加到容器中。
>back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。