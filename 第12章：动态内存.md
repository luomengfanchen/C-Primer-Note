# 第十二章 动态内存

## 概述
>除了自动对象和static对象外，C++还支持动态分配对象。  
>动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。  
>动态对象的正确释放是编程中极其容易出错的地方。  
>为了更安全地使用动态内存，标准库定义了两个智能指针类型来管理动态分配的对象  
>当一个对象被释放时，指向它的智能指针可以确保自动地释放它。

## 动态内存与智能指针
### 动态内存运算符
- new
    >在内存池中为对象分配空间并返回一个指向该对象的指针。
- delete
    >接受一个动态对象的指针，销毁该对象。
### 智能指针类
>智能指针的行为类似常规指针，重要的区别是它负责自动的释放所指向的对象。
- shared_ptr
    >允许多个指针指向同一个对象
- unique_ptr
    >“独占”所指向的对象
- weak_ptr
    >一种弱引用，指向shared_ptr所管理的对象

## shared_ptr类
>智能指针也是模板。因此当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。  
>默认初始化的智能指针中保存着一个空指针
### make_shared函数
>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。
### 引用计数(reference count)
>对于每个shared_ptr都有一个相关联的计数器

## 直接管理内存
### 使用new动态分配内存和初始化对象
>在自由空间分配的内存时无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针  
>在默认情况下，动态分配的内存是默认初始化的。
### 使用delete释放内存
>我们通过delete表达式将动态内存归还给系统  
>delete表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

## unique_ptr类
>一个unique_ptr类“拥有”它所指向的对象。  
>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。  
>当unique_ptr被销毁时，它所指向的对象也被销毁

## weak_ptr类
>waek_ptr是一种不控制所指向对象生存期的智能指针。  
>它指向由一个shared_ptr管理的对象。  
>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。  
>一旦最后一个指向对象的shared_ptr被销毁，对象就会释放

## 动态数组
>C++语言提供了两种一次分配一个对象数组的方法。  
- C++语言定义了另一种new表达式语句，可以分配并初始化一个对象数组。
- 标准库中包含一个名为allocator的类
### new语句
```C++
int *pia = new int[get_size()];
```
### delete语句
```C++
delete [] pia;
```
### 智能指针和动态数组
>标准库中提供了一个可以管理new分配的数组的unqiue_ptr版本。  
>为了用一个unique_ptr管理动态数组，我们必须在对象类型后面加一对空括号
```C++
//up指向一个包含10个未初始化int的数组
std::unique_ptr<int[]> up(new int[10]);
//自动用delete[]销毁指针
up.release;
```

## allocator类
>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在这种情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正需要时才真正执行对象创建操作(同时付出一定开销)。

>标准库 *allocator* 类定义在 *memory* 中，它帮助我们将内存分配和对象构造分离开来。它提供了一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。  
>allocator分配的内存是未构造的(unconstructed)。我们需要在此内存中构造对象。

>当一个allocator对象分配对象时，他会根据给定的对象类型来确定恰当的内存大小和对齐位置。
```C++
//可以分配string的allocator对象
std::allocator<std::string> alloc;
//分配n个未初始化的string
auto cosnt p = alloc.allocate(n);
```