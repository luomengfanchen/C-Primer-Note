# 第十四章 重载运算符与类型转换

## 基本概念
- 重载运算符是具有特殊名字的函数：它们的名字有关键字 *operator* 和其后的要定义的运算符号共同组成。和其他函数一样，重载的运算符也包括返回类型、参数列表以及函数体。
- 重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。
- 对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。
- 除了重载的函数调用运算符 *operator()* 之外，其他重载运算符不能含有默认实参。

## 重载输出和输入运算符
>如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然，IO函数通常需要读写类的非共有数据成员，所以IO运算符一般被声明为友元。
### 重载输出运算符<<
- 通常情况下输出运算符的第一个形参是一个非常量的 *ostream* 对象的引用。
- 第二个形参一般来说是一个常量的引用。该常量是我们要打印的类类型。
>输出运算符尽量减少格式化操作，输出运算符应该主要负责打印对象而非控制格式，输出运算符不应该打印换行符。
```C++
ostream &operator<<(ostream &os, const int &item)
{
    os << item;
    return os;
}
```
### 重载输出运算符>>
- 通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)的对象的引用。
- 该运算符通常会返回某个给定流的引用。
- 第二形参之所以必须是个非常量是因为输入运算符本身的目的是将数据读入到这个对象中。
```C++
istream &operator>>(istream &is, int &item)
{
    is >> item;
    return is;
}
```

## 算术与关系运算符
- 通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。
- 因为这些运算符一般不需要改变运算对象的状态，所以形参都是对常量的引用。
### 算术运算符
- 算术运算符通常会他的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量中。
- 操作完成后返回该局部变量的副本作为其结果。
### 相等运算符
- 通常情况下，C++中的类通过定义相等运算符检验两个对象是否相等。
- 也就是说，它们会比较对象的每一个数据成员，只有当所有对应的相等时才认为两个对象相等。
### 关系运算符
>通常情况下关系运算符应该：
- 定义顺序关系，令其于关联容器中对关键字的要求一致。
- 如果类同时也含有==运算符的话，则定义一种关系运算符令其于==保持一致。特别是，如果有两个对象是!=的，那么一个对象应该<另外一个。

## 下标运算符
- 表示容器的类型的类通常可以通过在容器中的位置访问元素，这些类一般会定义下标运算符 *operator[]*
- 下标运算符必须是成员函数

## 递增和递减运算符
- 现代迭代器类中通常会实现递增和递减运算符，这两种运算符使得类可以在元素的序列中前后移动。
- C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的是所操作对象的状态，所以建议将其设定为成员函数。
- 定义递增和递减运算符的类应该同时定义前置版本和后置版本。
- 后置版本接受一个额外的(不被使用的)int类型的形参，当我们使用使用后置运算符时，编译器为这个形参提供一个值为零的实参。
- 对于后置版本来说，在递增对象之前首先记录对象的状态。
```C++
class T
{
    //前置版本
    T& operator++();
    T& operator--();
    //后置版本
    T& operator++(int);
    T& operator--(int);
}
```

## 成员访问运算符
- 在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(->)。
- 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。

## 函数调用运算符
- 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类也能同时存储状态，所以与普通函数相比它们更加灵活。
- 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。
- 如果类定义了调用运算符，则该类的对象称作 *函数对象(function object)*。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。
### 可调用对象与function
>C++语言有几种可调用的对象：
- 函数
- 函数指针
- lambda表达式
- bind创建的对象
- 重载了函数调用运算符的类

## 重载、类型转换与运算符
>转换构造函数和类型转换运算符共同定义了 *类类型转换(class-type conversions)*，这样的转换有时也被称作 *用户定义的类型转换(uesr-defined conversions)*。
### 类型转换运算符
- 类型转换运算符()是类的一种特殊成员函数。
- 它负责将一个类类型的值转换成其他类型。
>类型转换的一般形式如下所示：
```C++
operator type() const;
```
- 其中 *type* 表示某种类型。
- 类型转换运算符可以面向任意类型(除了void之外)进行定义，只要该类型能作为函数的返回类型。
- 因此，我们不允许转换成数组或者函数类型，但允许转换成指针(包括数组指针及函数指针)或者引用类型。
- **一个类型转换运算符必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。**
### 显式的类型转换运算符
>C++11新标准引入了 *显式的类型转换运算符(explicit-conversion operator)*。
```C++
explicit operator int() const;
```
### 避免有二义性的类型转换
- 如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们的代码很可能会具有二义性。
- 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。
### 函数重载与重载运算符
- 重载的运算符也是重载的函数。因此，通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。
- 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。