# 第十五章 面向对象程序设计

## 概述
>面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。  
>通过使用数据抽象，我们可以将类的接口与实现分离；  
>使用继承，可以定义相似的类型并对其相似关系建模；  
>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
### 继承
>通过继承(inheritance)联系在一起的类构成一种层次关系。  
>通常在层次关系的根部有一个 *基类(base class)*，其他类或间接或直接地从基类继承而来，这些继承得到的类称为 *派生类(derived class)*。  
>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自拥有的特有的成员。  
>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望他的派生类各自定义适合自身的版本，此时基类将这些函数声明成 *虚函数(virtual function)*。  
>派生类必须使用通过使用派生类列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟逗号分隔的基类列表，其中每个基类前面可以有访问说明符。
### 动态绑定
>通过使用 *动态绑定(dynamic binding)*，我们能用同一段代码分别处理基类和派生类的对象。  
>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时被称为运行时绑定(run-time binding)。  
>在C++语言中当我们使用基类的引用调用一个虚函数时发生运行时绑定。

## 定义基类和派生类
>基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
### 成员函数与继承
>派生类可以继承基类的成员，然而当遇到与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。  
>在C++语言中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。  
### 访问控制与继承
>派生类可以继承定义在基类中的成员，但是派生类中的成员函数不一定有权访问从基类继承而来的成员。  
>和其他使用的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候还有这样一种成员，基类希望他的派生类有权访问该成员，同时禁止其他成员访问。我们用 *受保护的(protected)* 访问运算符说明这样的成员。  
### 定义派生类
>派生类必须将其继承而来的成员函数中需要覆盖的哪些重新声明。  
>在类派生列表后的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。  
>访问说明符作用是控制派生类从基类而来的成员是否对派生类可见。  
#### 派生类中的虚函数
>派生类经常(但不总是)覆盖它继承的虚函数，如果派生类没有覆盖其基类中的某个虚函数，则该函数的行为类似于其他普通成员，派生类会直接继承在基类中的版本。
#### 派生类对象及派生类向基类的类型转换
>一个派生类对象包含多个组成部分：  
- 一个含有派生类自己定义的(非静态)成员的子对象。
- 一个与该派生类继承的基类对应的子对象。
- 如果有多个基类，那么这样的子对象也有多个。
>派生类到基类的(derive-to-base)类型转换，和其他类型一样编译器会隐式的执行派生类到基类的转换。  
>在派生类中含有与其基类对应的组成部分，这一事实是继承的关键所在。  
#### 派生类构造函数
>尽管在派生类中有基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化他的基类部分。  
>每个类控制它自己的成员初始化。
#### 派生类使用基类的成员
>派生类可以访问基类的公有成员和受保护的成员。
#### 继承与静态成员
>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。  
>不论从基类派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
#### 派生类的声明
派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。
#### 被用作基类的类
>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。  
>这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。  
>这一规定还有一层隐含的意思，即一个类不能派生它本身。
#### 防止继承的发生
>有时我们会定义这样一种类。我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。  
>为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final。
### 类型转换与继承
>理解基类与派生类之间的类型转换是理解C++语言的面向对象编程的关键所在。  
>我们可以将基类的指针或引用绑定到派生类对象上。  
>这样当我们使用基类的引用(或指针)时，实际上我们并不清楚该引用(或指针)所绑定对象的阵势类型。该对象可能时基类的对象，也可能时派生类的对象。
#### 静态类型与动态类型
>当我们使用存在继承关系的类型时，必须将一个变量或其他表达式 *静态类型(static type)* 与该表达式的 *动态类型(dynamic type)* 区分开来。
- 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。
- 动态类型则是变量或表达式表示的内存的对象的类型，动态类型直到运行时才可知。
#### 不存在基类向派生类的隐式转换
>之所以存在派生类向基类的转换是因为每个派生类都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。
#### 对象之间不存在类型转换
>派生类向基类的自动转换只对指针或引用有效，在派生类类型和其他基类类型之间不存在这样的转换。  
>很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这样转换的实际发生过程往往与我们期望的有所差别。

## 虚函数
>如前所述，在C++语言中，当我们使用基类的引用或指针调用调用一个虚函数时会执行动态绑定。  、
>因为我们知道运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。
### 对虚函数的调用可能现在运行时才被解析
>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。  
>被调用的函数是与绑定的到指针或引用上的对象的动态类型相匹配的那一个。  
>当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来。
### 派生类中的虚函数
>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。  
>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。  
>同样，派生类中虚函数的返回类型也必须与基类函数匹配，该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。
### final和override说明符
- override
    >派生类如果定义了一个函数与基类中的虚函数的名字相同但是形参列表不同，这仍然是合法的行为。  
    >编译器将认为新定义的这个与基类中原有的函数是相互独立的。  
    >这时，派生类的函数并没有覆盖掉基类中的版本。  
    >在C++11新标准中我们可以使用 *override* 关键字来说明派生类中的虚函数。  
    >这么做的好处是在使得程序员的意图更加清晰地同时让编译器可以为我们发现一些错误。  
    >如果我们使用override关键字标记了某个函数，但该函数并没有覆盖已存在的虚函数，这时编译器将报错。
- final
    >我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。
### 虚函数与默认实参
>和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。  
>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。  
>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一样。
### 回避虚函数机制
>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这以目的。

## 抽象基类
### 纯虚函数
- 将函数定义为 *纯虚(pure virtual)* 函数可以清晰明了的告诉用户当前这个函数是没有实际意义的。
- 和普通函数不一样，一个纯虚函数无须定义。
- 我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。
### 汉化由纯虚函数的类是抽象基类
- 含有(或者未经覆盖直接继承)的类是 *抽象基类(abstract base class)*。
- 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。
- 我们不能直接创建一个抽象基类的对象，而是创建一个通过抽象基类派生的派生类的对象。
### 派生类构造函数只初始化他的直接基类
- 如前所述，每个类各自控制其对象的初始化过程。
- 因此，即使某个派生类没有没有自己的数据成员，它也仍然需要提供一个构造函数。

## 访问控制与继承
>每个类分别控制着其成员对于派生类来说是否可访问(accessible)
### 受保护的成员
>如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。  
>protected说明符可以看作是public和private中和后的产物：
- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。
- 派生类中的成员或友元只能通过派生类对象来访问基类的受保护成员。
### 公有、私有和受保护继承
>某个类对其继承而来的成员的访问权限受到两个因素的影响：  
- 一是在基类中该成员的访问说明符，
- 二是在派生类中派生列表中的访问说明符。
>派生访问说明符对于派生类的成员(及友元)能否访问其基类的成员没什么影响。  
>对基类成员的访问权限只与基类中的访问说明符有关。  
>派生访问说明符的目的是控制派生类用户(包括派生类在内)对于基类成员的访问权限。  
>派生访问说明符还可以控制继承自派生类的新类的访问权限。
### 友元与继承
>就像友元关系不能传递一样，友元关系同样也不能继承。  
>基类的友元在派生类成员不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。  
>当一个类将另一个类声明成友元时，这种友元关系只对做出声明的类有效。对于原来的那个类来说，其友元的基类或者派生类不具有特殊的访问能力。
### 改变个别成员的可访问性
>有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的。
### 默认的继承保护级别
>默认情况下，使用class关键字定义的派生类是私有继承地。  
>而使用struct关键字定义的类是公有继承的。

## 继承中的类作用域
>每个类定义自己的作用域，在这个作用域内我们定义类的成员。  
>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。  
>如果一个名字在派生类的作用域无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。
### 在编译时进行名字查找
>一个对象、引用或指针的静态类型决定了该对象的那些成员事可见的。  
>即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况)，但是我们能使用的哪些成员任然是由静态类型决定的。
### 名字冲突与继承
>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，
>此时定义在内层作用域(即派生类)的名字将隐藏在外层作用域(即基类)的名字。  
>**派生类中的成员将隐藏同名的基类成员**
### 使用隐藏的成员
>我们可以通过作用域运算符来使用一个被隐藏的基类成员。
### 名字查找先于类型检查
>如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。  
>因此，定义在派生类中的函数也不会重载其基类中的成员。  
>如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名，则派生类将会在其作用域中隐藏该基类成员。  
>即使派生类成员和基类成员的形参列表不一致，基类成员也任然会被隐藏掉。
### 覆盖重载的函数
>我们通过未重载的成员提供一条using声明语句，这样我们就无须覆盖基类中的没一个重载版本了。

## 构造函数与拷贝控制
### 虚析构函数
>继承关系对基类拷贝控制最直接的影响就是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。
#### 虚析构函数将阻止合成移动操作
>如果一个类定义了一个虚析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。
### 合成拷贝控制与继承
>基类或派生类的合成拷贝控制成员的与其他合成的构造函数、赋值运算符或析构函数类似。  
>它们对类本身的成员依次进行初始化、赋值或销毁的操作。  
>并且对一个对象的基类部分进行初始化、赋值或销毁的操作。
#### 派生类中删除拷贝控制与基类的关系
>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义的成删除的函数。
### 派生类的拷贝控制成员
>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。
#### 定义派生类的拷贝或移动构造函数
>当为派生类定义的拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。
#### 派生类赋值运算符
>派生类的赋值运算符也必须显式的为其基类部分赋值。
#### 派生类析构函数
>派生类的析构函数只负责销毁由派生类自己分配的资源。
### 继承的构造函数
>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。  
>派生类继承基类构造函数的方法就是提供了一条注明了(直接)基类名的using声明的语句。
#### 继承的构造函数的特点
>一个构造函数的声明不会改变该构造函数的访问级别。  
>一个using声明语句也不能指定ecplict或constexpr。

## 容器与继承
>当我们使用容器存放继承体系的对象时，通常必须采取间接存储的方式。
### 在容器中放置(智能)指针而非对象
>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针(更好的选择是智能指针)。  
>和往常一样这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。