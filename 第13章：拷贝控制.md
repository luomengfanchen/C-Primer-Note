# 第十三章 拷贝控制

## 概述
>当定义一个类时，我们显示或隐式地指定此类型地对象地拷贝、移动、赋值和销毁时做什么。  
>一个类通过定义五种特殊地成员函数来控制这些操作：
- 拷贝构造函数(copy constructor)
- 拷贝赋值运算符(copy-assignment operator)
- 移动构造函数(move constructor)
- 移动赋值运算符(move-assignment operator)
- 析构函数(destructor)
>如果一个类没有定义所有这些操作，编译器会自动为它定义缺失地操作。称为：
- 合成拷贝构造函数
- 合成拷贝赋值运算符
- 合成移动构造函数
- 合成移动赋值运算符
- 合成析构函数
>对一些类来说，依赖这些操作地默认定义会导致灾难。

## 拷贝构造函数(copy constructor)
>若构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
```C++
Class Foo
{
public:
    //拷贝构造函数
    Foo(cosnt Foo&);
};
```

## 拷贝赋值运算符(copy-assignment operator)
>与类控制其对象如何初始化一样，类也以控制其对象如何赋值  

>重载运算符本质上是函数，其名字由operator关键字后接要定义的运算符的符号组成。  
>如果运算符是一个成员函数，其左侧对象就绑定到隐式的this参数。  
>对于一个二元函数，其右侧运算对象作为显示对象显示传递。
```C++
class Foo
{
public:
    Foo& operator=(const Foo&);
};
```
>赋值运算符通常应该返回指向其左侧对象的引用。

## 析构函数(destructor)
>析构函数执行工作与构造函数相反：  
>构造函数初始化对象的非static数据成员，还可能做一些其他操作；  
>析构函数释放对象使用的资源，并销毁对象的非static数据成员。

>析构函数是类的一个成员函数，名字由波浪号姐类名构成。它没有返回值，也不接受参数  
>由于析构函数不接送参数，因此它不能被重载。对于一个给定类，只会有唯一一个析构函数。
```C++
class Foo
{
public:
    ~Foo();
};
```

## 使用 =default
>我们为控制成员定义 *=default* 来来显示要求编译器生成合成的版本。  
>当我们在内类内用=default修饰成员时，合成的函数将隐式的声明为内联的。  
>如果我们不希望合成的成员函数是内联函数，应该只对成员的类外使用=default

## 组织拷贝(=delete)
>在新标准下，我们可以通过将拷贝构造函数和构造赋值运算符定义为删除的函数(delete function)来阻止拷贝。  
>删除的函数是一种这样的函数：我们虽然声明了他们，但不能以任何方式使用它们。  
>在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的。
```C++
class NoCopy
{
public:
    NoCopy() = default;
    NoCopy(cosnt NoCopy&) = delete;
    NoCopy& operator=(cosnt NoCopy&) = delete;
    ~NoCopy() = default;
};
```
>析构函数是不能删除的成员

## 交换操作(swap函数)
```C++
class HasPtr
{
    friend void swap(HasPtr&, HasPtr&);
private:
    int i;
    std::string *ps;
};
inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    std::swap(lhs.ps, rhs.ps);
    std::swap(lhs.i, rhs.i);
}
```

## 右值引用(rvalue reference)
>为了支持移动操作，新标准引入了一种的引用类型——右值引用。  
>所谓右值引用就是必须绑定到右值的引用。  
>我们通过&&而不是&来获得右值引用。  
>右值引用有一个特性：只能绑定到一个将要将要销毁的对象。



## 移动构造函数(move constructor)
>类似拷贝构造函数的第一个参数是该类类型的一个引用。  
>不同于拷贝构造函数的是，这个引用参数在移动构造函数是一个右值引用。  
>通常，移动构造函数将数据从其参数移动到新创建的对象中。  
>不抛出异常的移动构造函数必须标记为noexcept。

## 移动赋值运算符(move-assignment operator)
>接受一个本类型右值引用参数的版本，  
>通常，移动赋值运算符将数据从右侧运算对象移动到左侧运算对象。  
>不抛出异常的移动赋值运算符必须标记为noexcept。

## 移动迭代器
>新标准库中定义了一种移动迭代器适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。  
>一般来说，一个迭代器的解引用运算符返回一个指向元素的左值，与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。

## 引用限定符
>在参数列表后放置一个引用限定符(&或&&)，用来指出一个this可以指向一个左值或右值。  
>类似const限定符，引用限定符之恩用于(非static)的成员函数。

